/*!
 *
 * TypeIt - The most versatile animated typing utility on the planet.
 * Author: Alex MacArthur <alex@macarthur.me> (https://macarthur.me)
 * Version: v6.1.1
 * License: GPL-2.0
 * URL: https://typeitjs.com
 *
 */
! function(t, e) {
  "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports ? exports.TypeIt = e() : t.TypeIt = e()
}(this, (function() {
  return function(t) {
    var e = {};

    function i(n) {
      if (e[n]) return e[n].exports;
      var s = e[n] = {
        i: n,
        l: !1,
        exports: {}
      };
      return t[n].call(s.exports, s, s.exports, i), s.l = !0, s.exports
    }
    return i.m = t, i.c = e, i.d = function(t, e, n) {
      i.o(t, e) || Object.defineProperty(t, e, {
        enumerable: !0,
        get: n
      })
    }, i.r = function(t) {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
        value: "Module"
      }), Object.defineProperty(t, "__esModule", {
        value: !0
      })
    }, i.t = function(t, e) {
      if (1 & e && (t = i(t)), 8 & e) return t;
      if (4 & e && "object" == typeof t && t && t.__esModule) return t;
      var n = Object.create(null);
      if (i.r(n), Object.defineProperty(n, "default", {
          enumerable: !0,
          value: t
        }), 2 & e && "string" != typeof t)
        for (var s in t) i.d(n, s, function(e) {
          return t[e]
        }.bind(null, s));
      return n
    }, i.n = function(t) {
      var e = t && t.__esModule ? function() {
        return t.default
      } : function() {
        return t
      };
      return i.d(e, "a", e), e
    }, i.o = function(t, e) {
      return Object.prototype.hasOwnProperty.call(t, e)
    }, i.p = "", i(i.s = 0)
  }([function(t, e, i) {
    "use strict";
    i.r(e);
    var n = {
        strings: [],
        speed: 100,
        cursor: !0,
        cursorChar: "|",
        cursorSpeed: 1e3,
        deleteSpeed: null,
        lifeLike: !0,
        breakLines: !0,
        startDelay: 250,
        startDelete: !1,
        nextStringDelay: 750,
        loop: !1,
        loopDelay: 750,
        html: !0,
        waitUntilVisible: !1,
        beforeString: () => {},
        afterString: () => {},
        beforeStep: () => {},
        afterStep: () => {},
        afterComplete: () => {}
      },
      s = function() {
        var t = this;
        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
          i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
        this.insert = (t, e) => {
          this.waiting.splice(t, 0, e)
        }, this.add = function(e) {
          let i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          return Array.isArray(e[0]) ? (t.waiting = t.waiting.concat(e), t) : (t.waiting[i ? "unshift" : "push"](e), t)
        }, this.delete = t => (this.waiting.splice(t, 1), this), this.reset = () => (this.waiting = this.executed.concat(this.waiting), this.executed = [], this), this.executed = [], this.waiting = e, !e.length && i && this.add(i)
      },
      r = t => document.createElement(t);

    function o(t, e) {
      return Math.abs(Math.random() * (t + e - (t - e)) + (t - e))
    }

    function u(t) {
      let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "",
        i = r("style");
      i.id = e, i.appendChild(document.createTextNode(t)), document.head.appendChild(i)
    }
    var l = t => ["textarea", "input"].indexOf(t.tagName.toLowerCase()) > -1,
      a = t => Array.isArray(t) ? t : [t],
      h = t => [].slice.call(t);
    const c = (t, e) => {
      let i = t.nextSibling;
      return !!i && !i.isEqualNode(e)
    };
    var p = (t, e) => {
        let i = e;
        if (l(t)) return void(t.value = "".concat(t.value).concat(i));
        let n = h(t.childNodes).filter(t => t.classList && t.classList.contains("ti-cursor"));
        if (n = n.length ? n[0] : null, "object" == typeof e && !(e instanceof HTMLElement)) {
          let s = e.ancestorTree.slice(0).reverse().join(" "),
            o = h(t.querySelectorAll("".concat(s))),
            u = o[o.length - 1];
          if (u && ((t, e) => {
              if (!t) return !1;
              let i = !1,
                n = [],
                s = t;
              for (; !i;) n.push(c(s, e)), (s = s.parentNode) && !s.hasAttribute("data-typeit-id") || (i = !0);
              return !n.some(t => t)
            })(u, n)) t = u, i = e.content;
          else if (i = function(t) {
              let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
                i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "",
                n = r(t);
              return e.forEach(t => {
                n.setAttribute(t.name, t.value)
              }), n.innerHTML = i, n
            }(e.ancestorTree[0], e.attributes, e.content), e.ancestorTree.length > 1) {
            let i = h(t.querySelectorAll(e.ancestorTree[1]));
            t = i[i.length - 1]
          }
        }
        i = "object" == typeof i ? i : document.createTextNode(i), t.insertBefore(i, n && t.hasAttribute("data-typeit-id") ? n : null)
      },
      d = t => {
        let e = [];
        return e.concat.apply(e, t)
      },
      f = t => {
        let e = document.implementation.createHTMLDocument("");
        return e.body.innerHTML = t, e.body
      };
    const y = t => h(t.attributes).map(t => ({
        name: t.name,
        value: t.nodeValue
      })),
      g = t => h(t.childNodes).map(t => 3 === t.nodeType ? t.nodeValue.split("") : t),
      m = (t, e, i) => ({
        ancestorTree: e,
        attributes: y(t),
        content: i
      }),
      b = (t, e) => {
        let i = m(t, e, ""),
          n = g(t).map((i, n) => Array.isArray(i) ? i.map((i, n) => m(t, e, i)) : i);
        return n.unshift(i), d(n)
      },
      v = t => t instanceof HTMLElement && "BR" !== t.tagName,
      w = function t(e) {
        let i = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
          n = e.map(t => {
            if (v(t)) {
              if (!i) return h(t.childNodes);
              let e = t.parentNode,
                n = [t.tagName];
              for (;
                ["BODY", "HTML"].indexOf(e.tagName) < 0;) n.push(e.tagName), e = e.parentNode;
              return b(t, n)
            }
            return t
          });
        return (n = d(n)).some(t => v(t)) ? t(n, i) : n
      };

    function S(t) {
      let e = f(t),
        i = g(e);
      return w(i)
    }

    function q(t) {
      return !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1] ? S(t) : t.split("")
    }
    var x = (t, e) => {
        e ? t.value = "" : t.querySelector(".ti-cursor") && (t.innerHTML = "")
      },
      T = function(t, e) {
        let i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
          n = !Array.isArray(t),
          s = t.length;
        return (t = n ? new Array(t).fill(0) : t).map((t, r) => {
          if (n) return e;
          let o = [e, t];
          return i && (0 === r && o.push({
            isFirst: !0
          }), r + 1 === s && o.push({
            isLast: !0
          })), o
        })
      },
      A = t => {
        t.parentNode.removeChild(t)
      };
    const N = t => 3 !== t.nodeType && "BR" !== t.tagName && !t.firstChild,
      L = t => t.some(t => N(t));
    var M = t => {
        let e = h(t.querySelectorAll("*")),
          i = L(e);
        for (; e.length && i;) {
          let n = !1;
          e.forEach(t => {
            N(t) && (A(t), n = !0)
          }), n && (e = h(t.querySelectorAll("*"))), i = L(e)
        }
        return e
      },
      D = t => (Array.isArray(t) || (t = [t / 2, t / 2]), {
        before: t[0],
        after: t[1],
        total: t[0] + t[1]
      }),
      $ = function(t, e, i) {
        let n = (e = null !== e ? e : t / 3) / 2;
        return i ? [o(t, t / 2), o(e, n)] : [t, e]
      };

    function j() {
      var t = this;
      let {
        typeIt: e,
        element: i,
        id: o,
        options: c,
        queue: d = [],
        isAReset: y = !1
      } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      const g = () => {
          let t = h(this.$e.childNodes).filter(t => !t.isEqualNode(L));
          return w(t, !1)
        },
        m = function(e) {
          let i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
            n = t.opts.nextStringDelay;
          t.queue.insert(e, [t.pause, n.before]), t.queue.insert(e + i + 1, [t.pause, n.after])
        },
        b = () => {
          !E && this.opts.cursor && (u("@keyframes blink-".concat(o, " { 0% {opacity: 0} 49% {opacity: 0} 50% {opacity: 1} }[data-typeit-id='").concat(o, "'] .ti-cursor { animation: blink-").concat(o, " ").concat(this.opts.cursorSpeed / 1e3, "s infinite; }"), o), (L = r("span")).innerHTML = f(this.opts.cursorChar).innerHTML, L.className = "ti-cursor", L.setAttribute("style", "display:inline;position:relative;font:inherit;color:inherit;line-height:inherit;"), this.$e.appendChild(L))
        };
      this.wait = function(t, e) {
        this.timeouts.push(setTimeout(t, e))
      };
      const v = () => {
          this.opts.strings.forEach((t, e) => {
            let i = q(t, this.opts.html);
            this.queue.add(T(i, this.type, !0));
            let n = this.queue.waiting.length;
            if (e + 1 !== this.opts.strings.length) {
              if (this.opts.breakLines) return this.queue.add([this.type, r("BR")]), void m(n);
              this.queue.add(T(i, this.delete)), m(n, t.length)
            }
          })
        },
        N = t => {
          this.queue.reset().delete(0).add([this.pause, t.before], !0);
          for (let t = 0; t < g().length; t++) this.queue.add([this.delete, null, {
            isPhantom: !0
          }], !0)
        };
      this.pause = function() {
        let t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        return new Promise((e, i) => {
          this.wait(() => e(), t || this.opts.nextStringDelay.total)
        })
      }, this.reset = function() {
        return this.queue.reset(), new j({
          typeIt: e,
          element: this.$e,
          id: o,
          options: this.opts,
          queue: this.queue.waiting,
          isAReset: !0
        })
      }, this.init = function() {
        if (this.status.started) return;
        if (b(), !this.opts.waitUntilVisible) return this.status.started = !0, this.fire();
        new IntersectionObserver((t, e) => {
          t.forEach(t => {
            t.isIntersecting && (this.fire(), e.unobserve(this.$e))
          })
        }, {
          threshold: 1
        }).observe(this.$e)
      }, this.fire = function() {
        let t = this.queue.waiting.slice(),
          i = Promise.resolve();
        for (let n = 0; n < t.length; n++) {
          let s = t[n],
            r = [s, this.queue, e];
          i = i.then(() => new Promise((t, e) => {
            if (this.status.frozen) return e();
            this.pace = $(this.opts.speed, this.opts.deleteSpeed, this.opts.lifeLike), s[2] && s[2].isFirst && this.opts.beforeString(...r), this.opts.beforeStep(...r), s[0].call(this, s[1], s[2]).then(() => {
              let e = this.queue.waiting.shift();
              return s[2] && s[2].isPhantom ? t() : (s[2] && s[2].isLast && this.opts.afterString(...r), this.opts.afterStep(...r), this.queue.executed.push(e), t())
            })
          }))
        }
        i.then(() => {
          if (this.opts.loop) {
            let t = this.opts.loopDelay ? this.opts.loopDelay : this.opts.nextStringDelay;
            this.wait(() => {
              N(t), this.fire()
            }, t.after)
          }
          this.status.completed = !0, this.opts.afterComplete(e)
        }).catch(() => {})
      }, this.type = function(t) {
        return "object" != typeof t || t.content ? new Promise(e => {
          this.wait(() => (p(this.$e, t), e()), this.pace[0])
        }) : (p(this.$e, t), Promise.resolve())
      }, this.empty = function() {
        return new Promise(t => (E ? this.$e.value = "" : h(this.$e.childNodes).forEach(t => {
          L.isEqualNode(t) || A(t)
        }), t()))
      }, this.delete = function() {
        let t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        return new Promise(e => {
          this.wait(() => {
            let i = g();
            return i.length && A(i[i.length - 1]), M(this.$e), t && i.length - 1 > 0 ? this.delete(!0).then(() => e()) : e()
          }, this.pace[1])
        })
      }, this.setOptions = function(t) {
        return new Promise(e => (this.opts = Object.assign({}, this.opts, t), e()))
      };
      let L = null,
        E = l(i);
      this.status = {
        started: !1,
        complete: !1,
        frozen: !1,
        destroyed: !1
      }, this.$e = i, this.timeouts = [], this.opts = Object.assign({}, n, c), this.opts.html = !E && this.opts.html, this.opts.nextStringDelay = D(this.opts.nextStringDelay), this.opts.loopDelay = D(this.opts.loopDelay), this.queue = new s(d, [this.pause, this.opts.startDelay]), this.$e.setAttribute("data-typeit-id", o), u("[data-typeit-id]:before {content: '.'; display: inline-block; width: 0; visibility: hidden;}"), x(i, E);
      let O = a(this.opts.strings);
      O = (t => {
        let e = this.$e.innerHTML;
        return e ? (this.$e.innerHTML = "", this.opts.startDelete ? (S(e).forEach(t => {
          p(this.$e, t)
        }), this.queue.add([this.delete, !0]), m(1), t) : [e.trim()].concat(t)) : t
      })(O), this.opts.strings = O.map(t => t.replace(/<\!--.*?-->/g, "")), this.opts.strings.length && !y && v()
    }
    var E = function(t, e, i) {
        return !!t.length && !t.some((function(t) {
          return t.status[e] !== i
        }))
      },
      O = function(t) {
        return "string" == typeof t ? t = document.querySelectorAll(t) : t.forEach || (t = [t]), h(t)
      };

    function P(t, e) {
      var i = this;
      this.instances = O(t).map(t => new j({
        typeIt: this,
        element: t,
        id: Math.random().toString(36).substring(2, 15),
        options: e,
        queue: [],
        isAReset: !1
      }));
      const n = t => {
          this.instances.forEach(e => {
            t.call(this, e)
          })
        },
        s = function(t) {
          let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
            s = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
          n(n => {
            let r = "string" != typeof t,
              o = r ? t : n[t],
              u = T(s, [o, r ? i : e]);
            n.queue.add(u)
          })
        };
      this.is = function(t) {
        return E(this.instances, t, !0)
      }, this.freeze = function() {
        n(t => {
          t.status.frozen = !0
        })
      }, this.unfreeze = function() {
        n(t => {
          t.status.frozen && (t.status.frozen = !1, t.fire())
        })
      }, this.type = function() {
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
        return n(e => {
          let i = q(t, e.opts.html);
          e.queue.add(T(i, e.type, !0))
        }), this
      }, this.delete = function() {
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
        return s("delete", null === t, null === t ? 1 : t), this
      }, this.pause = function() {
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
        return s("pause", t), this
      }, this.break = function() {
        return s("type", r("BR")), this
      }, this.options = function(t) {
        return s("setOptions", t), this
      }, this.exec = function(t) {
        return s(t), this
      }, this.destroy = function() {
        let t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
        this.instances = this.instances.map(e => {
          if (e.timeouts.forEach(t => {
              clearTimeout(t)
            }), e.timeouts = [], t) {
            let t = e.isInput ? null : e.$e.querySelector(".ti-cursor");
            t && e.$e.removeChild(t)
          }
          return e.status.destroyed = !0, e
        })
      }, this.empty = function() {
        return s("empty"), this
      }, this.reset = function() {
        return this.destroy(), this.instances = this.instances.map(t => t.reset()), this
      }, this.go = function() {
        return n(t => {
          t.init()
        }), this
      }
    }
    i.d(e, "default", (function() {
      return P
    }))
  }]).default
}));
